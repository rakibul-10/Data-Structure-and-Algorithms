//Heap sort is an in-place algorithm.
//Time Complexity: O(n log n)
//Auxiliary Space: O(log n), due to the recursive call stack. However, auxiliary space can be O(1) for iterative implementation.

void heapify(int arr[],int n,int i)
{
    int largest=i;
    int left_child=2*i+1;
    int right_child=2*i+2;
    
    if(right_child<n && arr[right_child]>arr[largest])
        largest=right_child;
        
    if(left_child<n && arr[left_child]>arr[largest])
        largest=left_child;
        
    if(largest!=i)
    {
        swap(arr[i],arr[largest]);
        heapify(arr,n,largest);
    }
}
void heapsort(int arr[],int n)
{

    for(int i=n/2-1; i>=0; i--)
    {
        //Build a max-Heap
        heapify(arr,n,i);
    }

    //Extract elements one by one
    for(int i=n-1; i>=0; i--)
    {
        swap(arr[0],arr[i]);// Move root to end
        heapify(arr,i,0);//Heapify reduced heap
    }
}
void solve()
{
    int n;
    cin>>n;
    int arr[n];
    for(int i=0; i<n; i++)cin>>arr[i];
    heapsort(arr,n);
    for(int i=0; i<n; i++)cout<<arr[i]<<" ";
    cout<<endl;
}


                 ///priority_queue?
// A priority queue is a type of queue where elements are served based on priority, not order of insertion.

//Syntax
//priority_queue<Type> pq;   // Max Heap (default)
//priority_queue<Type, vector<Type>, greater<Type>> min_pq; // Min Heap


//With Custom Comparator (example: sort by second value in pair)

struct Compare {
    bool operator()(pair<int,int> a, pair<int,int> b) {
        return a.second > b.second; // Min Heap based on second value
    }
};

int main() {
    priority_queue<pair<int,int>, vector<pair<int,int>>, Compare> pq;

    pq.push({1, 50});
    pq.push({2, 30});
    pq.push({3, 40});

    while (!pq.empty()) {
        cout << pq.top().first << " " << pq.top().second << endl;
        pq.pop();
    }
}
